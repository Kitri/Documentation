* Scala Basics
** Classes
*** Class constructors
    Scala has primary and auxiliary constructors. The primary constructor is the class body

    #+BEGIN_SRC scala
      class Greeter(message: String) {
        def sayHi() = println(message)
      }

      val greeter = new Greeter("Hello")
      greeter.sayHi() //will print Hello
                      //Can also invoke as greeter.sayHi without params since it has no side effects (doesn't mutate anything)

    #+END_SRC

    Auxiliary constructors has to invoke either another aux ctor or primary
    Thus, all ctor's will eventually invoke the primary

    #+BEGIN_SRC scala
      class Greeter(message: String, secondMessage: String) {
        def this(message: String) = this(message, "")
        def sayHi() = println(message + secondMessage)
      }

      val greeter = new Greeter("Hello")
      greeter.sayHi() //will print Hello 

      val greeter2 = new Greeter("Hello", "World")
      greeter2.sayHi //will print Hello World
    #+END_SRC
    
*** Abstract classes
    Same as in OO, create by specifying abstract keyword, and can extend it

    #+BEGIN_SRC scala 
      abstract class Greeter {
        val message: String
        def sayHi() = println(message)
      }

      class FrenchGreeter extends Greeter {
        message = "Bonjour"
      }

      val greeter = new FrenchGreeter()
      greeter.sayHi // will print 'Bonjour'
    #+END_SRC
    
** Methods
*** Creating methods
    #+BEGIN_SRC scala
      def myMethod(param1: String, param2: Int) : String = {
        return s"${param1} ${param2}"
      }

      //can also omit return type and return keyword (unless wanting to return from middle of method)
      def myMethod(param1: String, param2: Int) = {
        s"${param1} ${param2}"
      }

    #+END_SRC

*** Calling methods
    #+BEGIN_SRC scala
      className.methodName("param")
      className methodName("param")
      className methodName "param" 
    #+END_SRC

** Ifs and loops
*** If statements are expressions
    #+BEGIN_SRC scala
      //one line
      result = if(a == b) "true" else "false"
    #+END_SRC

*** For comprehension or for expression

    Given a list of people:
    #+BEGIN_SRC scala
      class Person(val name: String, val female: Boolean)

      val people = List(
          new Person("Cliff Barnes", false),
          new Person("J. R. Ewing", false),
          new Person("Sue Ellen Ewing", true),
          new Person("Ellie Ewing", true),
          new Person("Bobby Ewing", false)
          new Person("Donna Culver Krebbs", true))
    #+END_SRC

    Traverse list, "comprehending each instance"
    #+BEGIN_SRC scala
      for(person <- people)
        println(person.name)
    #+END_SRC

    Scala's for loop can have filters
    #+BEGIN_SRC scala
      for(person: Person <- people
        if person.female)
        println(person.name)


      for(person: Person <- people
        if person.female
        if person.name.contains("Ewing"))
        println(person.name)

      //Can also declare variables in this part

      for(person: Person <- people
        if !person.female;
        name = person.name
        if name.contains("Ewing"))
        println(name)
    #+END_SRC
    
*** Nested loops
    #+BEGIN_SRC scala
      val ewings = List(
          new Person("J. R. Ewing", false),
          new Person("Sue Ellen Ewing", true),
          new Person("Ellie Ewing", true),
          new Person("Bobby Ewing", false))

      val outsiders = List(
          new Person("Cliff Barnes", false),
          new Person("Donna Culver Krebbs", true))
    
      val groups = List(ewings, outsiders)
    #+END_SRC
    
    To loop over all the objects in the lists inside the list
    #+BEGIN_SRC scala
      for(people <- groups; person <- people)
        println(person.name)
    #+END_SRC
    
    Can create new collections using yield for expressions
    #+BEGIN_SRC scala
      val names = for(person <- people) yield person.name

      for(name <- names) println(name)
    #+END_SRC

** Traits
   
*** Inheritance
    Consider the following birds:
    - Pigeon: Can swim and fly
    - Hawk: Can swim and fly
    - Penguin: Can swim
    - Frigatebird: Can fly
    #+BEGIN_SRC scala
      abstract class Bird

      trait Flying {
        def flyMessage: String
        def fly() = println(flyMessage)
      }

      trait Swimming {
        def swim() = println("I'm swimming")
      }


      class Pigeon extends Bird with Swimming with Flying {
        val flyMessage = "I'm a good flyer"
      }

      class Hawk extends Bird with Swimming with Flying {
        val flyMessage = "I'm an excellent flyer"
      }

      class Penguin extends Bird with Swimming

      class Frigatebird extends Bird with Flying {
        val flyMessage = "I'm an excellent flyer"
      }


      val flyingBirds = List(
        new Pigeon,
        new Hawk,
        new Frigatebird
      )

      flyingBirds.foreach(bird => bird.fly())

      val swimmingBirds = List(
        new Pigeon,
        new Hawk,
        new Penguin
      )

      swimmingBirds.foreach(bird => bird.swim())

    #+END_SRC
    #+BEGIN_SRC scala

    #+END_SRC
